// @flow
import { Navigation } from 'react-native-navigation';

export type Options = Object;

/**
 * This singleton follows the `currentScreenId` generated by the navigation library
 * This is to prevent prop drilling when wanting to navigate/style the `topBar`
 * Essentially, it provides a small abstraction over the `Navigation` methods
 * Could be nicer as a saga
 */

class Navigate {
    currentScreenId: string;

    currentPassProps: ?Object;

    screenIdStack: Array<string> = [];

    isReadyToNavigate = false;

    onNavigationReadyCallbacks = [];

    isModalOpen = false;

    /**
     * This is required to prevent "double tap" transitions on Android
     */
    isMidTransition = false;

    governScreenIdStack(screenId: string) {
        const indexOfScreen = this.screenIdStack.indexOf(screenId);

        // The screen is not already in the stack, so add it
        if (indexOfScreen === -1) {
            this.screenIdStack.push(screenId);
            return;
        }

        // Hot reloading can cause the screen to appear twice, so don't add a screen if it is already at the top of the stack
        if (indexOfScreen === this.screenIdStack.length - 1) {
            return;
        }

        // The screen is already in the stack, so remove all other screens on top of it
        this.screenIdStack = this.screenIdStack.slice(0, indexOfScreen + 1);
    }

    isScreenInStack(screenId: string) {
        return this.screenIdStack.includes(screenId);
    }

    isScreenVisible(screenId: string) {
        return this.currentScreenId === screenId;
    }

    setCurrentScreenId = (screenId: string) => {
        this.governScreenIdStack(screenId);
        this.currentScreenId = screenId;
    };

    /**
     * This provides a `safe` navigation method when you do not know where you are in the stack
     * e.g. when navigating from push notifications or navigating in a saga (please don't)
     * Do still use the regular `push` and `pop` methods when you know where you are and where you are going,
     * this will make it easier for us to move back to the intended usage of the navigation library
     */
    async pushOrPopToRoute(componentName: string, passProps?: Object, options?: Options) {
        if (this.currentScreenId === componentName) {
            return;
        }

        if (this.isScreenInStack(componentName)) {
            return this.popTo(componentName);
        }

        return this.push(componentName, passProps, options);
    }

    async push(componentName: string, passProps?: Object, options?: Options) {
        if (this.isMidTransition) {
            return;
        }

        try {
            this.isMidTransition = true;
            await Navigation.push(this.currentScreenId, {
                component: { name: componentName, id: componentName, passProps, options },
            });

            this.currentPassProps = passProps;
            this.isMidTransition = false;
        } catch (error) {
            this.isMidTransition = false;
        }
    }

    async pop() {
        if (this.isMidTransition) {
            return;
        }
        try {
            this.isMidTransition = true;

            // Hack for navigation from the map :(
            console.log(this.screenIdStack.length, this.screenIdStack);
            if (this.screenIdStack.length !== 2) {
                await Navigation.pop(this.currentScreenId);
            } else {
                this.isMidTransition = false;
                await Navigation.popToRoot(this.currentScreenId);
            }

            this.isMidTransition = false;
        } catch (error) {
            this.isMidTransition = false;
        }
    }

    async popTo(componentName: string) {
        if (this.isMidTransition) {
            return;
        }
        try {
            this.isMidTransition = true;
            await Navigation.popTo(componentName);
            this.isMidTransition = false;
        } catch (error) {
            this.isMidTransition = false;
        }
    }

    async popToRoot(screenId?: string) {
        if (this.isMidTransition) {
            return;
        }
        try {
            this.isMidTransition = true;
            await Navigation.popToRoot(screenId || this.currentScreenId);
            this.isMidTransition = false;
        } catch (error) {
            this.isMidTransition = false;
        }
    }

    async showModal(componentName: string, passProps?: Object) {
        if (this.isMidTransition) {
            return;
        }
        try {
            this.isMidTransition = true;
            await Navigation.showModal({
                stack: {
                    children: [
                        {
                            component: {
                                name: componentName,
                                id: componentName,
                                passProps,
                            },
                        },
                    ],
                },
            });
            this.isMidTransition = false;
            this.isModalOpen = true;
        } catch (error) {
            this.isMidTransition = false;
        }
    }

    async dismissModal() {
        if (this.isMidTransition) {
            return;
        }

        try {
            this.isMidTransition = true;
            await Navigation.dismissModal(this.currentScreenId);
            this.isMidTransition = false;
            this.isModalOpen = false;
        } catch (error) {
            this.isMidTransition = false;
        }
    }

    async setRoot(screenName: string, passProps?: Object) {
        if (this.isMidTransition) {
            return;
        }

        try {
            this.isReadyToNavigate = false;
            this.isMidTransition = true;
            await Navigation.setRoot({
                root: {
                    stack: {
                        children: [
                            {
                                component: {
                                    id: screenName,
                                    name: screenName,
                                    passProps,
                                },
                            },
                        ],
                    },
                },
            });
            this.isMidTransition = false;

            // Reinitialise the screen stack
            this.screenIdStack = [];

            // When calling `Navigation.setRoot`, update `hiveNavigate` with route id
            this.setCurrentScreenId(screenName);

            this.isReadyToNavigate = true;

            await Promise.all(this.onNavigationReadyCallbacks.map(callback => callback()));
            this.onNavigationReadyCallbacks = [];
        } catch (error) {
            this.isMidTransition = false;
        }
    }

    // Expose an API for storing functions to be run when navigation is ready (i.e. after `setRoot` has finished)
    onNavigationReady(callback: () => *) {
        if (!this.isReadyToNavigate) {
            this.onNavigationReadyCallbacks.push(callback);
            return;
        }

        return callback();
    }
}

export const navigate = new Navigate();
